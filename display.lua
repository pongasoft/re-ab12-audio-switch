format_version = "1.0"

local inputs = { "A1", "A2", "A3", "A4", "A5", "A6", "B1", "B2", "B3", "B4", "B5", "B6" }

--------------- Definition ----------------------
function gestureFunction(handlers)
  return function(props, di, sp)
    local gesture_definition = {
      custom_data = {},
      handlers = handlers
    }
    return gesture_definition
  end
end

function switchTapFunction(singleStateStep, input)
  return function(props, di, gi, cd) return handleSwitchTap(props, singleStateStep, input) end
end

function switchDrawFunction(singleStateStep, bank)
  return function(props, di, dr) return handleSwitchDraw(props, singleStateStep, bank) end
end

-- generated by lua create_display_handlers.lua
SwitchGestureA1 = gestureFunction{ on_tap = "SwitchTapA1" }
SwitchTapA1 = switchTapFunction(1, "A1")
SwitchDrawA1 = switchDrawFunction(1, "A")
SwitchGestureA2 = gestureFunction{ on_tap = "SwitchTapA2" }
SwitchTapA2 = switchTapFunction(2, "A2")
SwitchDrawA2 = switchDrawFunction(2, "A")
SwitchGestureA3 = gestureFunction{ on_tap = "SwitchTapA3" }
SwitchTapA3 = switchTapFunction(3, "A3")
SwitchDrawA3 = switchDrawFunction(3, "A")
SwitchGestureA4 = gestureFunction{ on_tap = "SwitchTapA4" }
SwitchTapA4 = switchTapFunction(4, "A4")
SwitchDrawA4 = switchDrawFunction(4, "A")
SwitchGestureA5 = gestureFunction{ on_tap = "SwitchTapA5" }
SwitchTapA5 = switchTapFunction(5, "A5")
SwitchDrawA5 = switchDrawFunction(5, "A")
SwitchGestureA6 = gestureFunction{ on_tap = "SwitchTapA6" }
SwitchTapA6 = switchTapFunction(6, "A6")
SwitchDrawA6 = switchDrawFunction(6, "A")
SwitchGestureB1 = gestureFunction{ on_tap = "SwitchTapB1" }
SwitchTapB1 = switchTapFunction(7, "B1")
SwitchDrawB1 = switchDrawFunction(7, "B")
SwitchGestureB2 = gestureFunction{ on_tap = "SwitchTapB2" }
SwitchTapB2 = switchTapFunction(8, "B2")
SwitchDrawB2 = switchDrawFunction(8, "B")
SwitchGestureB3 = gestureFunction{ on_tap = "SwitchTapB3" }
SwitchTapB3 = switchTapFunction(9, "B3")
SwitchDrawB3 = switchDrawFunction(9, "B")
SwitchGestureB4 = gestureFunction{ on_tap = "SwitchTapB4" }
SwitchTapB4 = switchTapFunction(10, "B4")
SwitchDrawB4 = switchDrawFunction(10, "B")
SwitchGestureB5 = gestureFunction{ on_tap = "SwitchTapB5" }
SwitchTapB5 = switchTapFunction(11, "B5")
SwitchDrawB5 = switchDrawFunction(11, "B")
SwitchGestureB6 = gestureFunction{ on_tap = "SwitchTapB6" }
SwitchTapB6 = switchTapFunction(12, "B6")
SwitchDrawB6 = switchDrawFunction(12, "B")

-- bank toggle
BankToggleGesture = gestureFunction{ on_tap = "BankToggleTap", on_release = "BankToggleRelease" }

-- bank toggle A
BankToggleGestureA = gestureFunction{ on_tap = "BankToggleTapA" }

-- bank toggle B
BankToggleGestureB = gestureFunction{ on_tap = "BankToggleTapB" }

-------------------------------------------------

local switchRect = { left = 0, top = 0, right = 20, bottom = 19 }

local propModeSingle = 0
local propModeMulti = 1

-- properties for switch

local propModeIdx = 1
local propStateSingleIdx = 2
local propStateSingleCVIdx = 3
local propStateSingleOverrideCV = 4
local propStateMultiIdx = 5
local propStateMidiIdx = 6
local propSwitchBankIdx = 7
local propSwitchBankCVIdx = 8

local colorSingleMode = { r = 255, g = 0, b = 0, a = 200 }
local colorMultiMode = { r = 255, g = 127, b = 0, a = 200 }
local colorMidiMode = { r = 255, g = 255, b = 0, a = 200 }
local colorDisabledByBank = { r = 0, g = 0, b = 0, a = 127 }

-- for a regular n-gon, x = cos(2 * k * pi / n), y = sin(2 * k * pi / n) for k = 1...n + translation...
function computeNGon()
  local nGonSides = 6
  local nGonSize = 10
  local rect = {}
  for k = 1, nGonSides do
    local c = 2 * k * math.pi / nGonSides
    rect[#rect + 1] = { x = nGonSize * math.cos(c) + 17, y = nGonSize * math.sin(c) + 14 }
  end
  return rect
end

local bankToggleRect = computeNGon()

local bankToggleRectAB = { left = 3, top = 3, right = 18, bottom = 17 }

local propBankIdx = 1
local propBankCVIdx = 2
local propBankOverrideCVIdx = 3
local propBankToggle = 4

local propBankNone = 0
local propBankA = 1
local propBankB = 2
local propBankAB = 3

local bankAToggles = {
  [propBankNone] = propBankA,
  [propBankA] = propBankNone,
  [propBankB] = propBankAB,
  [propBankAB] = propBankB,
}

local bankBToggles = {
  [propBankNone] = propBankB,
  [propBankA] = propBankAB,
  [propBankB] = propBankNone,
  [propBankAB] = propBankA,
}

local colorBankToggle = { r = 0, g = 0, b = 0, a = 80 }
local colorBankAB = { r = 0, g = 0, b = 0, a = 200 }

-- handle tap on a switch (singleStateStep represents the step in single mode)
function handleSwitchTap(props, singleStateStep, input)
  local changes = {}
  local uiText = ""

  if props[propModeIdx] == propModeMulti then

    -- jbox.trace("Tap[" .. singleStateStep .. "] - Handle Multi Mode")
    changes[propStateMultiIdx] = not props[propStateMultiIdx]
    uiText = "cd handleSwitchTap_multi_" .. tostring(changes[propStateMultiIdx])
  elseif props[propModeIdx] == propModeSingle then

    changes[propStateSingleOverrideCV] = not props[propStateSingleOverrideCV]

    if props[propStateSingleCVIdx] > 0 then
      -- jbox.trace("Tap - Handle Single Mode.. overriding CV: " .. tostring(props[propStateSingleOverrideCV]))
      changes[propStateSingleIdx] = singleStateStep
    else
      -- jbox.trace("Tap - Handle Single Mode: " .. props[propStateSingleIdx])
      if props[propStateSingleIdx] == singleStateStep then
        -- toggle the step if you press on it again
        changes[propStateSingleIdx] = 0
      else
        changes[propStateSingleIdx] = singleStateStep
      end
    end

    uiText = "cd handleSwitchTap_single_" .. tostring(changes[propStateSingleIdx] == singleStateStep)

  else
    -- jbox.trace("Tap - MidiX - ignoring... ")
  end

  if uiText == "" then
    return { property_changes = changes }
  else
    uiText = uiText .. "_" .. input
    return { gesture_ui_name = jbox.ui_text(uiText), property_changes = changes }
  end

end

-- handle drawing the switch
function handleSwitchDraw(props, singleStateStep, bank)
  if props[propModeIdx] == propModeMulti then
    -- jbox.trace("Draw - Handle Multi Mode")

    if props[propStateMultiIdx] then
      jbox_display.draw_rect(switchRect, colorMultiMode)
    end

  elseif props[propModeIdx] == propModeSingle then
    -- jbox.trace("Draw - Handle Single Mode: " .. props[propStateSingleIdx] .. " / " .. props[propStateSingleCVIdx])

    local singleStateIdx = props[propStateSingleIdx]

    if props[propStateSingleCVIdx] > 0 then
      singleStateIdx = props[propStateSingleCVIdx]
    end

    if singleStateIdx == singleStateStep then
      jbox_display.draw_rect(switchRect, colorSingleMode)
    end

  else
    -- jbox.trace("Draw - Handle Midi Mode")

    if props[propStateMidiIdx] then
      jbox_display.draw_rect(switchRect, colorMidiMode)
    end
  end

  local propBank = props[propSwitchBankIdx]
  if props[propSwitchBankCVIdx] > 0 then
    propBank = props[propSwitchBankCVIdx] - 1
  end

  if bank == "A" then
    if propBank == propBankNone or propBank == propBankB then
      jbox_display.draw_rect(switchRect, colorDisabledByBank)
    end
  else
    if propBank == propBankNone or propBank == propBankA then
      jbox_display.draw_rect(switchRect, colorDisabledByBank)
    end
  end

  -- jbox.trace("handleSwitchDraw " .. tostring(singleStateStep) .. " bank=" .. tostring(propBank))

end

-- handle bank toggle tap
BankToggleTap = function(props, di, gi, cd)
  -- jbox.trace("BankToggleTap: " .. tostring(props[propBankIdx]))

  local changes = {}

  local propBank = props[propBankIdx]
  if props[propBankCVIdx] > 0 then
    propBank = props[propBankCVIdx] - 1
    -- jbox.trace("propBank from CV " .. propBank)
    changes[propBankOverrideCVIdx] = not props[propBankOverrideCVIdx]
  else
    -- jbox.trace("propBank from UI " .. propBank)
  end

  if props[propBank] == propBankA then
    changes[propBankIdx] = propBankB
  else
    changes[propBankIdx] = propBankA
  end

  changes[propBankToggle] = true

  return { gesture_ui_name = jbox.ui_text("cd BankToggleTap"), property_changes = changes }

end

-- handle bank toggle release
BankToggleRelease = function(props, di, gi, cd)
  -- jbox.trace("BankToggleRelease")

  local changes = {}

  changes[propBankToggle] = false

  return { property_changes = changes }

end

-- handle bank toggle draw
BankToggleDraw = function(props, di, dr)
  -- jbox.trace("BankToggleDraw")

  if props[propBankToggle] then
    jbox_display.draw_polygon(bankToggleRect, colorBankToggle)
  end

end

-- handle bank toggle for A or B
function handlBankToggleTapX(props, toggle, bankToggles)
  -- jbox.trace("BankToggleTap" .. toggle .. ": " .. tostring(props[propBankIdx]))

  local changes = {}

  local propBank = props[propBankIdx]
  if props[propBankCVIdx] > 0 then
    propBank = props[propBankCVIdx] - 1
    changes[propBankOverrideCVIdx] = not props[propBankOverrideCVIdx]
  end

  changes[propBankIdx] = bankToggles[propBank]

  local uiText = "cd handlBankToggleTapX_" .. toggle

  return { gesture_ui_name = jbox.ui_text(uiText), property_changes = changes }
end

-- handle bank toggle tap A
BankToggleTapA = function(props, di, gi, cd)
  return handlBankToggleTapX(props, "A", bankAToggles)
end

-- handle bank toggle tap B
BankToggleTapB = function(props, di, gi, cd)
  return handlBankToggleTapX(props, "B", bankBToggles)
end

-- handle bank toggle draw for A or B

function handleBankToggleDrawX(props, toggle, propOtherBank)
  -- jbox.trace("BankToggleDraw" .. toggle)

  local propBank = props[propBankIdx]
  if props[propBankCVIdx] > 0 then
    propBank = props[propBankCVIdx] - 1
  end

  -- note that we paint on the opposite to darken the LED background which is lit
  if propBank == propBankNone or propBank == propOtherBank then
    jbox_display.draw_rect(bankToggleRectAB, colorBankAB)
  end
end

-- handle bank toggle draw A
BankToggleDrawA = function(props, di, dr)
  handleBankToggleDrawX(props, "A", propBankB)
end


-- handle bank toggle draw A
BankToggleDrawB = function(props, di, dr)
  handleBankToggleDrawX(props, "B", propBankA)
end
